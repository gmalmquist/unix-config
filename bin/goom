#!/usr/bin/env python3
from __future__ import print_function, with_statement

import json
import os
import re
import sys
import tkinter
import urllib.request

from collections import namedtuple
from contextlib import contextmanager
from hashlib import sha1
from http.server import BaseHTTPRequestHandler, HTTPServer
from subprocess import Popen, PIPE, check_output
from textwrap import dedent


# Inset for positioning windows. This accounts for window decorations the window manager adds that
# exceed the nominal window boundaries.
INSET = (4, 16) # x, y

# Don't allow sequences of hotkey cords longer than this.
MAX_CORD_SEQUENCE = 4

# Port for the daemon's command server to listen on.
# Note that the command server binds to localhost on this port, meaning that it will only accept
# network traffic from processes running on this machine. This is good for security reasons.
DAEMON_PORT = 8993

# Regexes for parsing output from various unix utilities.
WINDOW_PATTERN = re.compile(r'Window\s+(?P<id>\d+)')
POSITION_PATTERN = re.compile(r'Position:\s+(?P<x>\d+),(?P<y>\d+)\s+[(]screen:\s+(?P<screen>\d+)[)]')
GEOMETRY_PATTERN = re.compile(r'Geometry:\s+(?P<width>\d+)x(?P<height>\d+)')
PROP_ONELINE = re.compile(r'(?P<name>[a-zA-Z0-9_]+)[(](?P<type>[a-zA-Z0-9_]+)[)]\s+=\s*(?P<value>.*)')
PROP_MULTILINE = re.compile(r'(?P<name>[a-zA-Z0-9_]+)[(](?P<type>[a-zA-Z0-9_]+)[)]:\s*(?P<value>.*)')


class WindowAction(object):
  def __init__(self):
    pass

  def execute(self, window):
    """Execute this action on the given Window instance."""
    raise ValueError('Must be implemented by subclass.')

  def render_text(self):
    """Render this window action as text, possibly with ascii art."""
    raise ValueError('Must be implemented by subclass.')

  def serialize(self):
    """Serialize this to a settings file.

    Should return a list where the first element is the name of
    the class, and subsequent elements are constructor arguments.
    """
    raise ValueError('Must be implemented by subclass.')

  @classmethod
  def load(cls, serialized):
    subclass = eval(serialized[0])
    return subclass(*serialized[1:])


class MoveAndResize(WindowAction):
  def __init__(self, x, y, w, h):
    self.x = x
    self.y = y
    self.w = w
    self.h = h

  def execute(self, window):
    window.move_and_resize(self.x, self.y, self.w, self.h)

  def _box_art(self, y, h):
    if y < 25:
      if h <= 25:
        return '⠉' 
      if h <= 50:
        return '⠛' 
      if h <= 75:
        return '⠿'
      return '⣿'
    if y < 50:
      if h <= 25:
        return '⠒'
      if h <= 50:
        return '⠶' 
      return '⣶'
    if y < 75:
      if h <= 25:
        return '⠤'
      return '⣤'
    return '⣀'

  def render_text(self, double=False):
    collapse = {
      '⠉ ': '⠁',
      '⠒ ': '⠂',
      '⠤ ': '⠄',
      '⣀ ': '⡀',
      '⠛ ': '⠃',
      '⠶ ': '⠆',
      '⣤ ': '⡄',
      '⠿ ': '⠇',
      '⣶ ': '⡆',
      '⣿ ': '⡇',
      ' ⠉': '⠈',
      ' ⠒': '⠐',
      ' ⠤': '⠠',
      ' ⣀': '⢀',
      ' ⠛': '⠘',
      ' ⠶': '⠰',
      ' ⣤': '⢠',
      ' ⠿': '⠸',
      ' ⣶': '⢰',
      ' ⣿': '⢸',
    }
    columns = []
    N = 8
    x, y, w, h = map(float, [self.x, self.y, self.w, self.h])
    for i in range(N):
      left = 100 * i / N
      right = 100 * (i + 1) / N
      if right < x or left > x + w:
        columns.append('⠀')
        continue
      columns.append(self._box_art(y, h))
    if not double:
      shortened = []
      for i in range(0, len(columns), 2):
        pair = '{}{}'.format(columns[i], columns[i + 1]).replace('⠀', ' ')
        shortened.append(collapse.get(pair, columns[i]))
      columns = shortened
    return '┃{}┃ (move and resize)'.format(''.join(columns))

  def serialize(self):
    return ['MoveAndResize', self.x, self.y, self.w, self.h]


class LoadSnapshot(WindowAction):
  def __init__(self, name):
    self.name = name

  def execute(self, window):
    load_window_state([self.name], {})

  def render_text(self):
    return 'Load Snapshot "{}"'.format(self.name)

  def serialize(self):
    return ['LoadSnapshot', self.name]


class KeyCords(object):
  _BUILTIN = {
    (frozenset(['c']),): MoveAndResize(100 * 1/6, 0, 100 * 4/6, 100),
    (frozenset(['Left']),): MoveAndResize(0, 0, 50, 100),
    (frozenset(['Right']),): MoveAndResize(50, 0, 50, 100),
    (frozenset(['Up']),): MoveAndResize(0, 0, 100, 50),
    (frozenset(['Down']),): MoveAndResize(0, 50, 100, 50),
    (frozenset(['Left', 'Up']),): MoveAndResize(0, 0, 50, 50),
    (frozenset(['Left', 'Down']),): MoveAndResize(0, 50, 50, 50),
    (frozenset(['Right', 'Up']),): MoveAndResize(50, 0, 50, 50),
    (frozenset(['Right', 'Down']),): MoveAndResize(50, 50, 50, 50),
    (frozenset(['1']),): MoveAndResize(0, 0, 1/3*100, 100),
    (frozenset(['2']),): MoveAndResize(0, 0, 2/3*100, 100),
    (frozenset(['3']),): MoveAndResize(2/3*100, 0, 1/3*100, 100),
    (frozenset(['4']),): MoveAndResize(1/3*100, 0, 2/3*100, 100),
    (frozenset(['Up']), frozenset(['Up']),): MoveAndResize(0, 0, 100, 100),
    (frozenset(['space']),): MoveAndResize(0, 0, 100, 100),
    (frozenset(['t']),): LoadSnapshot('foobar'),
  }

  _SHORTCUTS = dict(_BUILTIN)

  @classmethod
  def load(cls):
    if not os.path.exists(get_cache_file_path('settings/shortcuts.json')):
      return
    with open_cache_file('settings/shortcuts.json', 'r') as f:
      try:
        data = json.loads(f.read())
      except Exception as e:
        sys.stderr.write(str(e))
        sys.stderr.flush()
        return
    cls._SHORTCUTS = {}
    for shortcut in data.get('shortcuts', []):
      cords = tuple(frozenset(cord.split('+')) for cord in shortcut.get('cords', '').split(' '))
      command = WindowAction.load(shortcut.get('action'))
      cls._SHORTCUTS[cords] = command

  @classmethod
  def save(cls):
    result = {}
    result['shortcuts'] = []
    for sequence in cls.get_sequences():
      result['shortcuts'].append({
        'cords': ' '.join('+'.join(c) for c in sequence),
        'action': cls.get_command(sequence).serialize()
      })
    with open_cache_file('settings/shortcuts.json', 'w') as f:
      f.write(json.dumps(result, indent=2, sort_keys=True))

  @classmethod
  def get_sequences(cls):
    return sorted(cls._SHORTCUTS, key=lambda cord: (len(cord),) + tuple(map(len, cord)))

  @classmethod
  def get_command(cls, cords):
    key = tuple(map(frozenset, ((s.upper() for s in cs) for cs in cords)))
    # Find longest trailing match.
    for sequence in reversed(cls.get_sequences()):
      seq = tuple(map(frozenset, ((s.upper() for s in cs) for cs in sequence)))
      if len(key) >= len(seq) and tuple(key[-len(seq):]) == seq:
        return cls._SHORTCUTS[sequence]
    return cls._SHORTCUTS.get(key)


class CommandServer(BaseHTTPRequestHandler):
  @classmethod
  def start_server(cls):
    old_pid = get_daemon_pid()
    if old_pid is not None:
      check_output(['kill', '-9', old_pid])
    with open_cache_file('daemon.pid', 'w') as f:
      f.write(str(os.getpid()))
    try:
      KeyCords.load()
      print('Starting server ...')
      server = HTTPServer(('localhost', DAEMON_PORT), cls)
      server.serve_forever()
    except KeyboardInterrupt:
      print('Keyboard interrupt, shutting down.')
    finally:
      os.remove(get_cache_file_path('daemon.pid'))

  def do_POST(self):
    self.do_GET()

  def do_GET(self):
    print('Received GET', self.path)
    commands = get_commands(for_server=True)
    command_name = self.path[1:].replace('/', ' ')
    command_args = []
    space = command_name.find(' ')
    if space >= 0:
      command_args = command_name[space + 1:].split(' ')
      command_name = command_name[:space]
    if command_name not in commands:
      self.send_response(400)
      self.send_header('content-type', 'text/plain')
      self.end_headers()
      self.wfile.write('No such command {}'.format(command_name).encode())
      return
    try:
      positional, flags = parse_args(command_args)
      output = commands[command_name](positional, flags)
    except Exception as e:
      output = str(e)

    self.send_response(200)
    self.send_header('content-type', 'text/plain')
    self.end_headers()
    output_width = 0 if output is None else max(len(line) for line in output.split('\n'))
    self.wfile.write('Executed: {}\n{}\n{}'.format(' '.join([command_name]+command_args), '=' * output_width, output or '').encode())


class Screen(object):
  _SIZES = {}

  def __init__(self, id):
    self.id = id

  @property
  def size(self):
    if self.id not in Screen._SIZES:
      Screen._SIZES[self.id] = get_screen_size(self.id)
    return Screen._SIZES[self.id]

  def percent_to_pixel(self, percent_x, percent_y):
    w, h = self.size
    return int(w * float(percent_x) / 100), int(h * float(percent_y) / 100)

  def pixel_to_percent(self, pixel_x, pixel_y):
    w, h = self.size
    return 100 * float(pixel_x) / w, 100 * float(pixel_y) / h


class Window(object):
  def __init__(self, id):
    self.id = id
    self._geometry = None
    self._props = None

  def clear_cache(self):
    self._geometry = None
    self._props = None

  @property
  def geometry(self):
    if self._geometry is None:
      self._geometry = get_geometry(self.id)
    return self._geometry

  @property
  def props(self):
    if self._props is None:
      self._props = get_window_props(self.id)
    return self._props

  @property
  def desktop(self):
    return self.props.get('_NET_WM_DESKTOP')

  @property
  def allowed_actions(self):
    return self.props.get('_NET_WM_ALLOWED_ACTIONS', '').split(', ')

  @property
  def role(self):
    roles = self.props.get('WM_WINDOW_ROLE', [])
    return roles[0] if roles else ''

  @property
  def classes(self):
    return self.props.get('WM_CLASS', [])

  @property
  def name(self):
    for name in self.props.get('_NET_WM_NAME', []):
      return name
    for name in self.props.get('WM_NAME', []):
      return name
    return ''

  @property
  def pid(self):
    return self.props.get('_NET_WM_PID')

  @property
  def state(self):
    return self.props.get('_NET_WM_STATE') or self.props.get('WM_STATE')

  @property
  def screen(self):
    return Screen(self.geometry.screen)

  def move(self, percent_x, percent_y):
    screen = self.screen
    x, y = screen.percent_to_pixel(percent_x, percent_y)
    xdotool('windowmove', self.id, x, y)

  def resize(self, percent_w, percent_h):
    screen = self.screen
    w, h = screen.percent_to_pixel(percent_w, percent_h)
    xdotool('windowsize', self.id, w, h)

  def move_and_resize(self, percent_x, percent_y, percent_w, percent_h):
    screen = self.screen
    x, y = screen.percent_to_pixel(percent_x, percent_y)
    w, h = screen.percent_to_pixel(percent_w, percent_h)

    inset_x, inset_y = INSET
    x += inset_x
    y += inset_y
    w -= inset_x * 2
    h -= inset_y * 2

    if float(percent_x) < 0:
      x = int(self.geometry.x)
    if float(percent_y) < 0:
      y = int(self.geometry.y)
    if float(percent_w) < 0:
      w = int(self.geometry.width)
    if float(percent_h) < 0:
      h = int(self.geometry.height)

    xdotool('windowsize', self.id, w, h)
    xdotool('windowmove', self.id, x, y)
    # Sometimes we don't end up quite where we wanted, because
    # we hit the edge of the screen. Correct the x,y position here:
    self.clear_cache()
    #print('0 Delta x/y', int(self.geometry.x) - x, int(self.geometry.y) - y)
    #print('0 Delta w/h', int(self.geometry.width) - w, int(self.geometry.height) - h)
    new_x, new_y = map(int, [self.geometry.x, self.geometry.y])
    delta_x, delta_y = new_x - x, new_y - y
    if delta_x == 0 and delta_y == 0:
      return

    target_x, target_y = x, y
    target_w, target_h = w, h

    if delta_x < 0:
      # We were too wide, and got shunted left.
      target_x += abs(delta_x)
      target_w -= abs(delta_x)
    elif delta_x > 0:
      # We went farther left than the desktop supports.
      target_w -= abs(delta_x)

    if delta_y < 0:
      # We tried to go too far down, and got shunted up.
      target_y += abs(delta_y)
      target_h -= abs(delta_y)
    elif delta_y > 0:
      # We went farther up than the desktop supports.
      target_h -= abs(delta_y)

    xdotool('windowsize', self.id, target_w, target_h)
    xdotool('windowmove', self.id, target_x, target_y)

    # Below just for debugging.
    #self.clear_cache()
    #new_w, new_h = map(int, [self.geometry.width, self.geometry.height])
    #delta_w, delta_h = new_w - w, new_h - h
    #print('1 Delta x/y', int(self.geometry.x) - x, int(self.geometry.y) - y)
    #print('1 Delta w/h', int(self.geometry.width) - w, int(self.geometry.height) - h)
    #print(self.geometry.x, self.geometry.y, self.geometry.width, self.geometry.height)
    #print()


class Geometry(object):
  def __init__(self, id, x=None, y=None, width=None, height=None, screen=None):
    self.id = id
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.screen = screen

  def __repr__(self):
    return dedent('''
      Geom(
        id = {id}
        screen = {screen}
        x = {x}
        y = {y}
        width = {width}
        height = {height}
      )
    ''').strip().format(**self.as_dict())

  def as_dict(self):
    screen = Screen(self.screen)
    x, y = screen.pixel_to_percent(self.x, self.y)
    w, h = screen.pixel_to_percent(self.width, self.height)
    return {
      'id': self.id,
      'x': x,
      'y': y,
      'width': w,
      'height': h,
      'screen': self.screen,
    }


class KeyCordApp(tkinter.Frame):
  def __init__(self, master=None):
    super().__init__(master)
    self.master = master
    self.active_window = xdotool('getactivewindow')
    self.pack(fill=tkinter.X, padx=10, pady=10)
    self.create_widgets()
    screen_width = master.winfo_screenwidth()
    screen_height = master.winfo_screenheight()
    w, h = master.winfo_reqwidth(), master.winfo_reqheight()
    master.geometry('+{}+{}'.format(
      int(screen_width/2 - w/2), int(screen_height/2 - h)
    ))
    self.bind('<KeyPress>', self.handle_keypress)
    self.bind('<KeyRelease>', self.handle_keyrelease)
    self.bind('<FocusOut>', lambda _: self.master.destroy())
    self.focus_set()
    self.cords = []
    self.current_cord = set()
    self.current_pressed = set()
    self.done = False

  def handle_keypress(self, event):
    if self.done:
      return
    if event.keysym == 'Escape':
      self.done = True
      self.master.destroy()
      return
    if event.keysym == 'Enter' or event.keysym == 'Return':
      self.cords.append(frozenset(self.current_cord))
      self.current_cord = set()
      self.done = True
      self.process_cords()
      self.master.destroy()
      return
    self.current_pressed.add(event.keysym)
    self.current_cord.add(event.keysym)

  def handle_keyrelease(self, event):
    if self.done or event.keysym == 'Escape':
      return
    if event.keysym in self.current_pressed:
      self.current_pressed.remove(event.keysym)
    else:
      return
    if not self.current_pressed:
      # It would appear that this is the end
      # of a cord.
      self.cords.append(set(self.current_cord))
      if len(self.cords) > MAX_CORD_SEQUENCE:
        self.cords = self.cords[1:]
      self.current_cord = set()
      self.process_cords()

  def process_cords(self):
    cords = tuple(frozenset(c) for c in self.cords if len(c) > 0)
    command = KeyCords.get_command(cords)
    if command is not None:
      command.execute(Window(self.active_window))
    else:
      print('No commands for cord:',
        ' '.join('+'.join(c) for c in self.cords))

  def create_widgets(self):
    self.winfo_toplevel().title('goom - totally not moom')
    labels = []
    for sequence in KeyCords.get_sequences():
      command = KeyCords.get_command(sequence)
      key_text = ' '.join('+'.join(cord) for cord in sequence)
      cmd_text = command.render_text()
      labels.append((key_text, cmd_text))
    longest_key_text = max(len(k) for k, c in labels)
    for key_text, cmd_text in labels:
      text = '{}: {}{}'.format(key_text, ' '*(longest_key_text - len(key_text)), cmd_text)
      w = tkinter.Label(self, text=text, anchor='w', font=('Noto Mono', 10))
      w.pack(side='top', fill=tkinter.X)
    self.quit = tkinter.Button(self,
      text='QUIT',
      command=self.master.destroy)
    self.quit.pack(side='bottom', padx=20, pady=20)


def help(commands):
  print(dedent('''
    Usage:
      goom <command> <args> <--flags>
  ''').strip())
  print()
  print('  Commands:')
  for command in commands:
    print('    {}'.format(command))


def save_window_state(positional, flags):
  snapshot_name = positional[0] if positional else None
  if not snapshot_name:
    raise ValueError('Snapshot name is required.')
  hasher = sha1()
  hasher.update(snapshot_name.encode('utf8'))
  sid = hasher.hexdigest()
  windows = get_desktop_windows()
  with open_cache_file('snapshot/{}.json'.format(sid), 'w') as f:
    f.write(json.dumps({
      'name': snapshot_name,
      'windows': [{
        'geometry': w.geometry.as_dict(),
        'role': w.role,
        'name': w.name,
        'classes': w.classes,
        'state': w.state,
      } for w in windows],
    }, indent=2, sort_keys=True))


def load_window_state(positional, flags):
  snapshot_name = positional[0] if positional else None
  if not snapshot_name:
    raise ValueError('Snapshot name is required.')
  hasher = sha1()
  hasher.update(snapshot_name.encode('utf8'))
  sid = hasher.hexdigest()
  windows = get_desktop_windows()
  with open_cache_file('snapshot/{}.json'.format(sid), 'r') as f:
    snapshot = json.loads(f.read())
  pairs = []
  used = set()
  for snap_window in snapshot['windows']:
    for window in windows:
      if window.id in used:
        continue
      if tuple(snap_window['classes']) == tuple(window.classes):
        pairs.append((snap_window, window))
        used.add(window.id)
      break
  for snap_window, window in pairs:
    x_percent, y_percent = snap_window['geometry']['x'], snap_window['geometry']['y']
    w_percent, h_percent = snap_window['geometry']['width'], snap_window['geometry']['height']
    screen = Screen(window.geometry.screen)
    x, y = screen.percent_to_pixel(x_percent, y_percent)
    w, h = screen.percent_to_pixel(w_percent, h_percent)
    xdotool('windowmove', window.id, x, y, 'windowsize', window.id, w, h)


def print_window_props(positional, flags):
  for id in positional:
    print(json.dumps(get_window_props(id), indent=2, sort_keys=True))


def process_key_cord(positional, flags):
  tk = tkinter.Tk()
  key_cord_app = KeyCordApp(master=tk)
  key_cord_app.mainloop()


def move_and_resize(positional, flags):
  POS_PATTERN = re.compile('^(?P<x>\d+([.]\d+)?)\s*,\s*(?P<y>\d+([.]\d+)?)$')
  DIM_PATTERN = re.compile('^(?P<w>\d+([.]\d+)?)\s*x\s*(?P<h>\d+([.]\d+)?)$')
  ALL_PATTERN = re.compile('^(?P<x>\d+([.]\d+)?),(?P<y>\d+([.]\d+)?)\s+(?P<w>\d+([.]\d+)?)x(?P<h>\d+([.]\d+)?)$')
  INT_PATTERN = re.compile('^\d+([.]\d+)?$')

  tx = lambda x: x
  ty = lambda y: y

  if flags.get('grid') or flags.get('g'):
    grid_spec = flags.get('grid') or flags.get('g')
    # We interpret "0,0" as "rows,cols", and "0x0" as "width x height"
    m = POS_PATTERN.match(grid_spec)
    rows, cols = None, None
    if m:
      rows, cols = map(int, (m.group('x'), m.group('y')))
    m = DIM_PATTERN.match(grid_spec)
    if m:
      cols, rows = map(int, (m.group('w'), m.group('h')))
    if rows is None or cols is None:
      return dedent('''
        Expected --grid (-g) to be in one of the formats, but was {}:
          rows , cols
          width x height
      ''').format(grid_spec)
    tx = lambda x: 100 * float(x) / int(cols)
    ty = lambda y: 100 * float(y) / int(rows)

  active_window = Window(xdotool('getactivewindow'))

  x, y, w, h = (-1,) * 4

  if len(positional) == 4 and all(map(INT_PATTERN.match, positional)):
    x, y, w, h = positional
    x, w = map(tx, (x, w))
    y, h = map(ty, (y, h))
  elif len(positional) == 2 and all(map(INT_PATTERN.match, positional)):
    x, y = positional
    x = tx(x) ; y = ty(y)
  elif len(positional) == 2 and POS_PATTERN.match(positional[0]) and DIM_PATTERN.match(positional[1]):
    pos = POS_PATTERN.match(positional[0])
    dim = DIM_PATTERN.match(positional[1])
    x, y = pos.group('x'), pos.group('y')
    w, h = dim.group('w'), dim.group('h')
    x, w = map(tx, (x, w))
    y, h = map(ty, (y, h))
  elif len(positional) == 1 and ALL_PATTERN.match(positional[0]):
    match = ALL_PATTERN.match(positional[0])
    x, y = match.group('x'), match.group('y')
    w, h = match.group('w'), match.group('h')
    x, w = map(tx, (x, w))
    y, h = map(ty, (y, h))
  elif len(positional) == 1 and POS_PATTERN.match(positional[0]):
    pos = POS_PATTERN.match(positional[0])
    x, y = pos.group('x'), pos.group('y')
    x = tx(x) ; y = ty(y)
  elif len(positional) == 1 and DIM_PATTERN.match(positional[0]):
    dim = DIM_PATTERN.match(positional[0])
    w, h = dim.group('w'), dim.group('h')
    w = tx(w) ; h = ty(h)
  else:
    return dedent('''
      Invalid positional arguments. Usage:

        Move a window to x=10%, y=30%:
          move-and-resize 10 30
          move-and-resize 10,30

        Resize a window to w=50%, h=100%
          move-and-resize 50x100

        Move and resize a window to x=10%, y=30%, w=50%, h=20%
          move-and-resize 10 30 50 20
          move-and-resize 10,30 50x20
          move-and-resize '10,30 50x20'
    ''').strip()
  if float(w) < 0 and float(h) < 0:
    active_window.move(x, y)
    return
  active_window.move_and_resize(x, y, w, h)


@contextmanager
def open_cache_file(name, mode):
  path = get_cache_file_path(name)
  if not os.path.exists(os.path.dirname(path)):
    os.makedirs(os.path.dirname(path))
  with open(path, mode) as f:
    yield f


def get_cache_file_path(name):
  return os.path.expanduser(os.path.join('~/.cache/goom', name))


def get_screen_size(id):
  output = check_output(['xrandr', '--screen', str(id)]).decode('utf-8')
  match = re.compile(r'\s+current\s+(?P<width>\d+)\s*x\s*(?P<height>\d+)\s*,').search(output)
  if not match:
    raise ValueError('Could not determine screen size from xrandr.')
  return int(match.group('width')), int(match.group('height'))


def get_geometry(wid):
  geom = Geometry(wid)
  for line in xdotool('getwindowgeometry', wid).split('\n'):
    wpm = WINDOW_PATTERN.search(line)
    if wpm is not None:
      geom.id = wpm.group('id')
      continue
    ppm = POSITION_PATTERN.search(line)
    if ppm is not None:
      geom.x = ppm.group('x')
      geom.y = ppm.group('y')
      geom.screen = ppm.group('screen')
      continue
    gpm = GEOMETRY_PATTERN.search(line)
    if gpm is not None:
      geom.width = gpm.group('width')
      geom.height = gpm.group('height')
  return geom


def get_desktop_windows():
  """Get windows for the active desktop."""
  desktop = xdotool('get_desktop').strip()
  results = []
  for id in get_all_window_ids():
    window = Window(id)
    if window.desktop != desktop:
      continue
    if '_NET_WM_ACTION_MOVE' not in window.allowed_actions:
      continue
    results.append(window)
  return results


def get_desktop_for_window(id):
  desktop = get_window_props(id).get('_NET_WM_DESKTOP')
  if desktop is None:
    raise ValueError('Could not identify desktop for {}'.format(id))
  return desktop


def get_window_props(id):
  current_prop_name = None
  current_prop_lines = None
  props = {}
  for line in xprop('-id', id).split('\n'):
    match_oneline = PROP_ONELINE.match(line)
    match_multiline = PROP_MULTILINE.match(line)
    if match_oneline or match_multiline:
      if current_prop_lines is not None:
        props[current_prop_name] = '\n'.join(current_prop_lines)
        current_prop_names, current_prop_lines = None, None
    else:
      if current_prop_lines is not None:
        current_prop_lines.append(line)
      continue
    match = match_oneline if match_oneline else match_multiline
    if match_oneline:
      raw_value = match.group('value')
      value = raw_value
      if match.group('type') == 'STRING' or match.group('type') == 'UTF8_STRING':
        value = json.loads('[{}]'.format(raw_value))
      props[match.group('name')] = value
    else:
      current_prop_name = match.group('name')
      current_prop_lines = [match.group('value')]
  if current_prop_lines is not None:
    props[current_prop_name] = '\n'.join(current_prop_lines)
  return { p: (dedent(value).strip() if isinstance(value, str) else value) for p, value in props.items() }


def get_all_window_ids():
  for line in xprop('-root').split('\n'):
    if line.startswith('_NET_CLIENT_LIST(WINDOW):'):
      return [int(s, 0) for s in line[line.find('#') + 1:].strip().split(', ')]
  raise ValueError('Failed to find window ids.') 


def get_daemon_pid():
  path = get_cache_file_path('daemon.pid')
  if not os.path.exists(path):
    return None
  with open(path, 'r') as f:
    return f.read().strip()


def xprop(*cmd):
  command = ['xprop']
  command.extend(map(str, cmd))
  return check_output(command).decode('utf-8').strip()


def xdotool(*cmd):
  command = ['xdotool']
  command.extend(map(str, cmd))
  return check_output(command).decode('utf-8').strip()


def get_commands(for_server=False):
  commands = {
    'save-snapshot': save_window_state,
    'load-snapshot': load_window_state,
    'print-window-props': print_window_props,
    'key-cord': process_key_cord,
    'move-and-resize': move_and_resize,
    'mar': move_and_resize,
  }
  if for_server:
    # Shortcuts live in-memory, so saving/loading only
    # makes sense in that context.
    commands.update({
      'save-shortcuts': lambda _,__: KeyCords.save(),
      'load-shortcuts': lambda _,__: KeyCords.load(),
    })
  else:
    commands.update({
      'daemon': lambda pos, flags: CommandServer.start_server(),
    })
  return commands


def main(positional, flags):
  commands = get_commands()
  if not positional:
    help(sorted(commands))
    return
  command_name = positional[0]
  if command_name not in commands:
    help(sorted(commands))
    return
  if command_name != 'daemon' and get_daemon_pid() is not None:
    # Prefer issue a GET request to the server.
    command_tokens = positional + ['--{}={}'.format(k, v) for k, v in flags.items()]
    try:
      with urllib.request.urlopen('http://localhost:{port}/{command_string}'.format(
        port=DAEMON_PORT,
        command_string='/'.join(command_tokens))) as f:
        print (f.read().decode('utf-8'))
        return
    except Exception as e:
      sys.stderr.write('Failed to issue command to daemon, falling back on direct execution.\n')
      sys.stderr.write(str(e))
      sys.stderr.write('\n')
      sys.stderr.flush()
  output = commands[command_name](positional[1:], flags)
  if output is not None:
    print(output)


def parse_args(sargs):
  positional = []
  flags = {}
  for a in sargs:
    if a.startswith('-'):
      a = a.lstrip('-')
      eq = a.find('=')
      if eq > 0:
        flags[a[:eq]] = a[eq + 1:]
      else:
        flags[a] = True
    else:
      positional.append(a)
  return positional, flags


if __name__ == '__main__':
  main(*parse_args(sys.argv[1:]))
