#!/usr/bin/env python3
from __future__ import print_function, with_statement

import json
import os
import re
import sys
import tkinter

from collections import namedtuple
from contextlib import contextmanager
from hashlib import sha1
from http.server import BaseHTTPRequestHandler, HTTPServer
from subprocess import Popen, PIPE, check_output
from textwrap import dedent


# Inset for positioning windows. This accounts for window decorations the window manager adds that
# exceed the nominal window boundaries.
INSET = (4, 16) # x, y

# Don't allow sequences of hotkey cords longer than this.
MAX_CORD_SEQUENCE = 4

# Regexes for parsing output from various unix utilities.
WINDOW_PATTERN = re.compile(r'Window\s+(?P<id>\d+)')
POSITION_PATTERN = re.compile(r'Position:\s+(?P<x>\d+),(?P<y>\d+)\s+[(]screen:\s+(?P<screen>\d+)[)]')
GEOMETRY_PATTERN = re.compile(r'Geometry:\s+(?P<width>\d+)x(?P<height>\d+)')
PROP_ONELINE = re.compile(r'(?P<name>[a-zA-Z0-9_]+)[(](?P<type>[a-zA-Z0-9_]+)[)]\s+=\s*(?P<value>.*)')
PROP_MULTILINE = re.compile(r'(?P<name>[a-zA-Z0-9_]+)[(](?P<type>[a-zA-Z0-9_]+)[)]:\s*(?P<value>.*)')


class WindowAction(object):
  def __init__(self):
    pass

  def execute(self, window):
    """Execute this action on the given Window instance."""
    raise ValueError('Must be implemented by subclass.')

  def render_text(self):
    """Render this window action as text, possibly with ascii art."""
    raise ValueError('Must be implemented by subclass.')

class MoveAndResize(WindowAction):
  def __init__(self, x, y, w, h):
    self.x = x
    self.y = y
    self.w = w
    self.h = h

  def execute(self, window):
    window.move_and_resize(self.x, self.y, self.w, self.h)

  def _box_art(self, y, h):
    if y < 25:
      if h <= 25:
        return '⠉' 
      if h <= 50:
        return '⠛' 
      if h <= 75:
        return '⠿'
      return '⣿'
    if y < 50:
      if h <= 25:
        return '⠒'
      if h <= 50:
        return '⠶' 
      return '⣶'
    if y < 75:
      if h <= 25:
        return '⠤'
      return '⣤'
    return '⣀'

  def render_text(self, double=False):
    collapse = {
      '⠉ ': '⠁',
      '⠒ ': '⠂',
      '⠤ ': '⠄',
      '⣀ ': '⡀',
      '⠛ ': '⠃',
      '⠶ ': '⠆',
      '⣤ ': '⡄',
      '⠿ ': '⠇',
      '⣶ ': '⡆',
      '⣿ ': '⡇',
      ' ⠉': '⠈',
      ' ⠒': '⠐',
      ' ⠤': '⠠',
      ' ⣀': '⢀',
      ' ⠛': '⠘',
      ' ⠶': '⠰',
      ' ⣤': '⢠',
      ' ⠿': '⠸',
      ' ⣶': '⢰',
      ' ⣿': '⢸',
    }
    columns = []
    N = 8
    x, y, w, h = map(float, [self.x, self.y, self.w, self.h])
    for i in range(N):
      left = 100 * i / N
      right = 100 * (i + 1) / N
      if right < x or left > x + w:
        columns.append('⠀')
        continue
      columns.append(self._box_art(y, h))
    if not double:
      shortened = []
      for i in range(0, len(columns), 2):
        pair = '{}{}'.format(columns[i], columns[i + 1]).replace('⠀', ' ')
        shortened.append(collapse.get(pair, columns[i]))
      columns = shortened
    return '┃{}┃ (move and resize)'.format(''.join(columns))


class LoadSnapshot(WindowAction):
  def __init__(self, name):
    self.name = name

  def execute(self, window):
    load_window_state([self.name], {})

  def render_text(self):
    return 'Load Snapshot "{}"'.format(self.name)


class KeyCords(object):
  _BUILTIN = {
    (frozenset(['c']),): MoveAndResize(100 * 1/6, 0, 100 * 4/6, 100),
    (frozenset(['Left']),): MoveAndResize(0, 0, 50, 100),
    (frozenset(['Right']),): MoveAndResize(50, 0, 50, 100),
    (frozenset(['Up']),): MoveAndResize(0, 0, 100, 50),
    (frozenset(['Down']),): MoveAndResize(0, 50, 100, 50),
    (frozenset(['Left', 'Up']),): MoveAndResize(0, 0, 50, 50),
    (frozenset(['Left', 'Down']),): MoveAndResize(0, 50, 50, 50),
    (frozenset(['Right', 'Up']),): MoveAndResize(50, 0, 50, 50),
    (frozenset(['Right', 'Down']),): MoveAndResize(50, 50, 50, 50),
    (frozenset(['1']),): MoveAndResize(0, 0, 1/3*100, 100),
    (frozenset(['2']),): MoveAndResize(0, 0, 2/3*100, 100),
    (frozenset(['3']),): MoveAndResize(2/3*100, 0, 1/3*100, 100),
    (frozenset(['4']),): MoveAndResize(1/3*100, 0, 2/3*100, 100),
    (frozenset(['Up']), frozenset(['Up']),): MoveAndResize(0, 0, 100, 100),
    (frozenset(['space']),): MoveAndResize(0, 0, 100, 100),
    (frozenset(['t']),): LoadSnapshot('foobar'),
  }

  def __init__(self):
    pass

  @classmethod
  def get_sequences(cls):
    return sorted(cls._BUILTIN, key=lambda cord: (len(cord),) + tuple(map(len, cord)))

  @classmethod
  def get_command(cls, cords):
    key = tuple(map(frozenset, cords))
    # Find longest trailing match.
    for sequence in reversed(cls.get_sequences()):
      if len(key) >= len(sequence) and tuple(key[-len(sequence):]) == sequence:
        return cls._BUILTIN[sequence]
    return cls._BUILTIN.get(key)


class CommandServer(BaseHTTPRequestHandler):
  @classmethod
  def start_server(cls):
    print('Starting server ...')
    server = HTTPServer(('localhost', 8993), cls)
    try:
      server.serve_forever()
    except KeyboardInterrupt:
      print('Keyboard interrupt, shutting down.')

  def do_POST(self):
    self.do_GET()

  def do_GET(self):
    print('Received GET', self.path)
    commands = get_commands(for_server=True)
    command_name = self.path[1:].replace('/', ' ')
    command_args = []
    space = command_name.find(' ')
    if space >= 0:
      command_args = command_name[space + 1:].split(' ')
      command_name = command_name[:space]
    if command_name not in commands:
      self.send_response(400)
      self.send_header('content-type', 'text/plain')
      self.end_headers()
      self.wfile.write('No such command {}'.format(command_name).encode())
      return
    self.send_response(200)
    self.send_header('content-type', 'text/plain')
    self.end_headers()
    self.wfile.write('Ok, executing {}'.format(command_name).encode())
    positional, flags = parse_args(command_args)
    commands[command_name](positional, flags)


class Screen(object):
  _SIZES = {}

  def __init__(self, id):
    self.id = id

  @property
  def size(self):
    if self.id not in Screen._SIZES:
      Screen._SIZES[self.id] = get_screen_size(self.id)
    return Screen._SIZES[self.id]

  def percent_to_pixel(self, percent_x, percent_y):
    w, h = self.size
    return int(w * float(percent_x) / 100), int(h * float(percent_y) / 100)

  def pixel_to_percent(self, pixel_x, pixel_y):
    w, h = self.size
    return 100 * float(pixel_x) / w, 100 * float(pixel_y) / h


class Window(object):
  def __init__(self, id):
    self.id = id
    self._geometry = None
    self._props = None

  def clear_cache(self):
    self._geometry = None
    self._props = None

  @property
  def geometry(self):
    if self._geometry is None:
      self._geometry = get_geometry(self.id)
    return self._geometry

  @property
  def props(self):
    if self._props is None:
      self._props = get_window_props(self.id)
    return self._props

  @property
  def desktop(self):
    return self.props.get('_NET_WM_DESKTOP')

  @property
  def allowed_actions(self):
    return self.props.get('_NET_WM_ALLOWED_ACTIONS', '').split(', ')

  @property
  def role(self):
    roles = self.props.get('WM_WINDOW_ROLE', [])
    return roles[0] if roles else ''

  @property
  def classes(self):
    return self.props.get('WM_CLASS', [])

  @property
  def name(self):
    for name in self.props.get('_NET_WM_NAME', []):
      return name
    for name in self.props.get('WM_NAME', []):
      return name
    return ''

  @property
  def pid(self):
    return self.props.get('_NET_WM_PID')

  @property
  def state(self):
    return self.props.get('_NET_WM_STATE') or self.props.get('WM_STATE')

  @property
  def screen(self):
    return Screen(self.geometry.screen)

  def move(self, percent_x, percent_y):
    screen = self.screen
    x, y = screen.percent_to_pixel(percent_x, percent_y)
    xdotool('windowmove', self.id, x, y)

  def resize(self, percent_w, percent_h):
    screen = self.screen
    w, h = screen.percent_to_pixel(percent_w, percent_h)
    xdotool('windowsize', self.id, w, h)

  def move_and_resize(self, percent_x, percent_y, percent_w, percent_h):
    screen = self.screen
    x, y = screen.percent_to_pixel(percent_x, percent_y)
    w, h = screen.percent_to_pixel(percent_w, percent_h)

    inset_x, inset_y = INSET
    x += inset_x
    y += inset_y
    w -= inset_x * 2
    h -= inset_y * 2

    xdotool('windowsize', self.id, w, h)
    xdotool('windowmove', self.id, x, y)
    # Sometimes we don't end up quite where we wanted, because
    # we hit the edge of the screen. Correct the x,y position here:
    self.clear_cache()
    #print('0 Delta x/y', int(self.geometry.x) - x, int(self.geometry.y) - y)
    #print('0 Delta w/h', int(self.geometry.width) - w, int(self.geometry.height) - h)
    new_x, new_y = map(int, [self.geometry.x, self.geometry.y])
    delta_x, delta_y = new_x - x, new_y - y
    if delta_x == 0 and delta_y == 0:
      return

    target_x, target_y = x, y
    target_w, target_h = w, h

    if delta_x < 0:
      # We were too wide, and got shunted left.
      target_x += abs(delta_x)
      target_w -= abs(delta_x)
    elif delta_x > 0:
      # We went farther left than the desktop supports.
      target_w -= abs(delta_x)

    if delta_y < 0:
      # We tried to go too far down, and got shunted up.
      target_y += abs(delta_y)
      target_h -= abs(delta_y)
    elif delta_y > 0:
      # We went farther up than the desktop supports.
      target_h -= abs(delta_y)

    xdotool('windowsize', self.id, target_w, target_h)
    xdotool('windowmove', self.id, target_x, target_y)

    # Below just for debugging.
    #self.clear_cache()
    #new_w, new_h = map(int, [self.geometry.width, self.geometry.height])
    #delta_w, delta_h = new_w - w, new_h - h
    #print('1 Delta x/y', int(self.geometry.x) - x, int(self.geometry.y) - y)
    #print('1 Delta w/h', int(self.geometry.width) - w, int(self.geometry.height) - h)
    #print(self.geometry.x, self.geometry.y, self.geometry.width, self.geometry.height)
    #print()


class Geometry(object):
  def __init__(self, id, x=None, y=None, width=None, height=None, screen=None):
    self.id = id
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.screen = screen

  def __repr__(self):
    return dedent('''
      Geom(
        id = {id}
        screen = {screen}
        x = {x}
        y = {y}
        width = {width}
        height = {height}
      )
    ''').strip().format(**self.as_dict())

  def as_dict(self):
    screen = Screen(self.screen)
    x, y = screen.pixel_to_percent(self.x, self.y)
    w, h = screen.pixel_to_percent(self.width, self.height)
    return {
      'id': self.id,
      'x': x,
      'y': y,
      'width': w,
      'height': h,
      'screen': self.screen,
    }


class KeyCordApp(tkinter.Frame):
  def __init__(self, master=None):
    super().__init__(master)
    self.master = master
    self.active_window = xdotool('getactivewindow')
    self.pack(fill=tkinter.X, padx=10, pady=10)
    self.create_widgets()
    screen_width = master.winfo_screenwidth()
    screen_height = master.winfo_screenheight()
    w, h = master.winfo_reqwidth(), master.winfo_reqheight()
    master.geometry('+{}+{}'.format(
      int(screen_width/2 - w/2), int(screen_height/2 - h)
    ))
    self.bind('<KeyPress>', self.handle_keypress)
    self.bind('<KeyRelease>', self.handle_keyrelease)
    self.bind('<FocusOut>', lambda _: self.master.destroy())
    self.focus_set()
    self.cords = []
    self.current_cord = set()
    self.current_pressed = set()
    self.done = False

  def handle_keypress(self, event):
    if self.done:
      return
    if event.keysym == 'Escape':
      self.done = True
      self.master.destroy()
      return
    if event.keysym == 'Enter' or event.keysym == 'Return':
      self.cords.append(frozenset(self.current_cord))
      self.current_cord = set()
      self.done = True
      self.process_cords()
      self.master.destroy()
      return
    self.current_pressed.add(event.keysym)
    self.current_cord.add(event.keysym)

  def handle_keyrelease(self, event):
    if self.done or event.keysym == 'Escape':
      return
    if event.keysym in self.current_pressed:
      self.current_pressed.remove(event.keysym)
    else:
      return
    if not self.current_pressed:
      # It would appear that this is the end
      # of a cord.
      self.cords.append(set(self.current_cord))
      if len(self.cords) > MAX_CORD_SEQUENCE:
        self.cords = self.cords[1:]
      self.current_cord = set()
      self.process_cords()

  def process_cords(self):
    cords = tuple(frozenset(c) for c in self.cords if len(c) > 0)
    command = KeyCords.get_command(cords)
    if command is not None:
      command.execute(Window(self.active_window))
    else:
      print('No commands for cord:',
        ' '.join('+'.join(c) for c in self.cords))

  def create_widgets(self):
    self.winfo_toplevel().title('goom - totally not moom')
    labels = []
    for sequence in KeyCords.get_sequences():
      command = KeyCords.get_command(sequence)
      key_text = ' '.join('+'.join(cord) for cord in sequence)
      cmd_text = command.render_text()
      labels.append((key_text, cmd_text))
    longest_key_text = max(len(k) for k, c in labels)
    for key_text, cmd_text in labels:
      text = '{}: {}{}'.format(key_text, ' '*(longest_key_text - len(key_text)), cmd_text)
      w = tkinter.Label(self, text=text, anchor='w', font=('Noto Mono', 10))
      w.pack(side='top', fill=tkinter.X)
    self.quit = tkinter.Button(self,
      text='QUIT',
      command=self.master.destroy)
    self.quit.pack(side='bottom', padx=20, pady=20)


def help(commands):
  print(dedent('''
    Usage:
      goom <command> <args> <--flags>
  ''').strip())
  print()
  print('  Commands:')
  for command in commands:
    print('    {}'.format(command))


def save_window_state(positional, flags):
  snapshot_name = positional[0] if positional else None
  if not snapshot_name:
    raise ValueError('Snapshot name is required.')
  hasher = sha1()
  hasher.update(snapshot_name.encode('utf8'))
  sid = hasher.hexdigest()
  windows = get_desktop_windows()
  with open_cache_file('snapshot/{}.json'.format(sid), 'w') as f:
    f.write(json.dumps({
      'name': snapshot_name,
      'windows': [{
        'geometry': w.geometry.as_dict(),
        'role': w.role,
        'name': w.name,
        'classes': w.classes,
        'state': w.state,
      } for w in windows],
    }, indent=2, sort_keys=True))


def load_window_state(positional, flags):
  snapshot_name = positional[0] if positional else None
  if not snapshot_name:
    raise ValueError('Snapshot name is required.')
  hasher = sha1()
  hasher.update(snapshot_name.encode('utf8'))
  sid = hasher.hexdigest()
  windows = get_desktop_windows()
  with open_cache_file('snapshot/{}.json'.format(sid), 'r') as f:
    snapshot = json.loads(f.read())
  pairs = []
  used = set()
  for snap_window in snapshot['windows']:
    for window in windows:
      if window.id in used:
        continue
      if tuple(snap_window['classes']) == tuple(window.classes):
        pairs.append((snap_window, window))
        used.add(window.id)
      break
  for snap_window, window in pairs:
    x_percent, y_percent = snap_window['geometry']['x'], snap_window['geometry']['y']
    w_percent, h_percent = snap_window['geometry']['width'], snap_window['geometry']['height']
    screen = Screen(window.geometry.screen)
    x, y = screen.percent_to_pixel(x_percent, y_percent)
    w, h = screen.percent_to_pixel(w_percent, h_percent)
    xdotool('windowmove', window.id, x, y, 'windowsize', window.id, w, h)


def print_window_props(positional, flags):
  for id in positional:
    print(json.dumps(get_window_props(id), indent=2, sort_keys=True))


def process_key_cord(positional, flags):
  tk = tkinter.Tk()
  key_cord_app = KeyCordApp(master=tk)
  key_cord_app.mainloop()


@contextmanager
def open_cache_file(name, mode):
  path = os.path.expanduser(os.path.join('~/.cache/goom', name))
  if not os.path.exists(os.path.dirname(path)):
    os.makedirs(os.path.dirname(path))
  with open(path, mode) as f:
    yield f


def get_screen_size(id):
  output = check_output(['xrandr', '--screen', str(id)]).decode('utf-8')
  match = re.compile(r'\s+current\s+(?P<width>\d+)\s*x\s*(?P<height>\d+)\s*,').search(output)
  if not match:
    raise ValueError('Could not determine screen size from xrandr.')
  return int(match.group('width')), int(match.group('height'))


def get_geometry(wid):
  geom = Geometry(wid)
  for line in xdotool('getwindowgeometry', wid).split('\n'):
    wpm = WINDOW_PATTERN.search(line)
    if wpm is not None:
      geom.id = wpm.group('id')
      continue
    ppm = POSITION_PATTERN.search(line)
    if ppm is not None:
      geom.x = ppm.group('x')
      geom.y = ppm.group('y')
      geom.screen = ppm.group('screen')
      continue
    gpm = GEOMETRY_PATTERN.search(line)
    if gpm is not None:
      geom.width = gpm.group('width')
      geom.height = gpm.group('height')
  return geom


def get_desktop_windows():
  """Get windows for the active desktop."""
  desktop = xdotool('get_desktop').strip()
  results = []
  for id in get_all_window_ids():
    window = Window(id)
    if window.desktop != desktop:
      continue
    if '_NET_WM_ACTION_MOVE' not in window.allowed_actions:
      continue
    results.append(window)
  return results


def get_desktop_for_window(id):
  desktop = get_window_props(id).get('_NET_WM_DESKTOP')
  if desktop is None:
    raise ValueError('Could not identify desktop for {}'.format(id))
  return desktop


def get_window_props(id):
  current_prop_name = None
  current_prop_lines = None
  props = {}
  for line in xprop('-id', id).split('\n'):
    match_oneline = PROP_ONELINE.match(line)
    match_multiline = PROP_MULTILINE.match(line)
    if match_oneline or match_multiline:
      if current_prop_lines is not None:
        props[current_prop_name] = '\n'.join(current_prop_lines)
        current_prop_names, current_prop_lines = None, None
    else:
      if current_prop_lines is not None:
        current_prop_lines.append(line)
      continue
    match = match_oneline if match_oneline else match_multiline
    if match_oneline:
      raw_value = match.group('value')
      value = raw_value
      if match.group('type') == 'STRING' or match.group('type') == 'UTF8_STRING':
        value = json.loads('[{}]'.format(raw_value))
      props[match.group('name')] = value
    else:
      current_prop_name = match.group('name')
      current_prop_lines = [match.group('value')]
  if current_prop_lines is not None:
    props[current_prop_name] = '\n'.join(current_prop_lines)
  return { p: (dedent(value).strip() if isinstance(value, str) else value) for p, value in props.items() }


def get_all_window_ids():
  for line in xprop('-root').split('\n'):
    if line.startswith('_NET_CLIENT_LIST(WINDOW):'):
      return [int(s, 0) for s in line[line.find('#') + 1:].strip().split(', ')]
  raise ValueError('Failed to find window ids.') 


def xprop(*cmd):
  command = ['xprop']
  command.extend(map(str, cmd))
  return check_output(command).decode('utf-8').strip()


def xdotool(*cmd):
  command = ['xdotool']
  command.extend(map(str, cmd))
  return check_output(command).decode('utf-8').strip()


def get_commands(for_server=False):
  commands = {
    'save-window-state': save_window_state,
    'load-window-state': load_window_state,
    'print-window-props': print_window_props,
    'key-cord': process_key_cord,
  }
  if not for_server:
    commands.update({
      'daemon': lambda pos, flags: CommandServer.start_server(),
    })
  return commands


def main(positional, flags):
  commands = get_commands()
  if not positional:
    help(sorted(commands))
    return
  i = 0
  while i < len(positional):
    pos = positional[i]
    if pos in commands:
      commands[pos](positional[i + 1:], flags)
      return
    i += 1


def parse_args(sargs):
  positional = []
  flags = {}
  for a in sargs:
    if a.startswith('-'):
      a = a.lstrip('-')
      eq = a.find('=')
      if eq > 0:
        flag[a[:eq]] = a[eq:]
      else:
        flag[a] = True
    else:
      positional.append(a)
  return positional, flags


if __name__ == '__main__':
  main(*parse_args(sys.argv[1:]))
