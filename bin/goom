#!/usr/bin/env python3
from __future__ import print_function, with_statement

import json
import os
import re
import shutil
import sys
import tkinter
import urllib.request

from collections import namedtuple
from contextlib import contextmanager
from hashlib import sha1
from http.server import BaseHTTPRequestHandler, HTTPServer
from subprocess import Popen, PIPE, check_output
from textwrap import dedent


# This script does not rely on external python packages,
# the standard libaries are sufficient. However, it does
# require the presence of certain external libraries and
# binaries:
# * tk      (for GUI bindings)
# * xprop   (to interrogate X about its windows)
# * xdotool (to move and resize windows)

# Inset for positioning windows. This accounts for window decorations the window manager adds that
# exceed the nominal window boundaries.
INSET = (4, 16) # x, y

# Don't allow sequences of hotkey chords longer than this.
MAX_CORD_SEQUENCE = 4

# Port for the daemon's command server to listen on.
# Note that the command server binds to localhost on this port, meaning that it will only accept
# network traffic from processes running on this machine. This is good for security reasons.
DAEMON_PORT = 8993

# Regexes for parsing output from various unix utilities.
WINDOW_PATTERN = re.compile(r'Window\s+(?P<id>\d+)')
POSITION_PATTERN = re.compile(r'Position:\s+(?P<x>\d+),(?P<y>\d+)\s+[(]screen:\s+(?P<screen>\d+)[)]')
GEOMETRY_PATTERN = re.compile(r'Geometry:\s+(?P<width>\d+)x(?P<height>\d+)')
PROP_ONELINE = re.compile(r'(?P<name>[a-zA-Z0-9_]+)[(](?P<type>[a-zA-Z0-9_]+)[)]\s+=\s*(?P<value>.*)')
PROP_MULTILINE = re.compile(r'(?P<name>[a-zA-Z0-9_]+)[(](?P<type>[a-zA-Z0-9_]+)[)]:\s*(?P<value>.*)')
POS_PATTERN = re.compile('^(?P<x>\d+([.]\d+)?)\s*,\s*(?P<y>\d+([.]\d+)?)$')
DIM_PATTERN = re.compile('^(?P<w>\d+([.]\d+)?)\s*x\s*(?P<h>\d+([.]\d+)?)$')
ALL_PATTERN = re.compile('^(?P<x>\d+([.]\d+)?),(?P<y>\d+([.]\d+)?)\s+(?P<w>\d+([.]\d+)?)x(?P<h>\d+([.]\d+)?)$')
INT_PATTERN = re.compile('^\d+([.]\d+)?$')

# Normalize key presses.
KEY_NORMALIZE = {
  'KP_0': '0',
  'KP_1': '1',
  'KP_2': '2',
  'KP_3': '3',
  'KP_4': '4',
  'KP_5': '5',
  'KP_6': '6',
  'KP_7': '7',
  'KP_8': '8',
  'KP_9': '9',
  'KP_Insert': '0',
  'KP_End': '1',
  'KP_Down': '2',
  'KP_Next': '3',
  'KP_Left': '4',
  'KP_Begin': '5',
  'KP_Right': '6',
  'KP_Home': '7',
  'KP_Up': '8',
  'KP_Prior': '9',
  'KP_Enter': 'Enter',
  'Return': 'Enter',
  'exclam': '1',
  'at': '2',
  'numbersign': '3',
  'dollar': '4',
  'percent': '5',
  'asciicircum': '6',
  'ampersand': '7',
  'asterisk': '8',
  'parenleft': '9',
  'parenright': '0',
  'Control_L': 'Control',
  'Control_R': 'Control',
  'Alt_L': 'Alt',
  'Alt_R': 'Alt',
  'Meta_L': 'Meta',
  'Meta_R': 'Meta',
  'Shift_L': 'Shift',
  'Shift_R': 'Shift',
  'Super_L': 'Super',
  'Super_R': 'Super',
}


class CliCommand(object):
  def __init__(self, name, description, delegate):
    self.name = name
    self.delegate = delegate
    self.description = description

  def __repr__(self):
    return '{}:  {}'.format(self.name, self.description)

  def __call__(self, *args, **kwargs):
    return self.delegate(*args, **kwargs)


class WindowAction(object):
  """An action that can be triggered by a keyboard shortcut.

  These actions typically operate on the active window, but
  they don't have to.
  """
  def __init__(self):
    pass

  def execute(self, window):
    """Execute this action on the given Window instance."""
    raise ValueError('Must be implemented by subclass.')

  def render_text(self):
    """Render this window action as text, possibly with ascii art."""
    raise ValueError('Must be implemented by subclass.')

  def serialize(self):
    """Serialize this to a settings file.

    Should return a list where the first element is the name of
    the class, and subsequent elements are constructor arguments.
    """
    raise ValueError('Must be implemented by subclass.')

  @classmethod
  def load(cls, serialized):
    subclass = eval(serialized[0])
    return subclass(*serialized[1:])


class MoveAndResize(WindowAction):
  """Window action that moves and resizes the active window."""

  def __init__(self, x, y, w, h, grid_spec=None):
    """Takes in the coordinates of the info, and optional grid dimensions as a string."""
    self.x = x
    self.y = y
    self.w = w
    self.h = h
    self.grid_spec = grid_spec

  def execute(self, window):
    window.move_and_resize(self.x, self.y, self.w, self.h, self.grid_spec)

  def _box_art(self, y, h):
    if y < 25:
      if h <= 25:
        return '⠉' 
      if h <= 50:
        return '⠛' 
      if h <= 75:
        return '⠿'
      return '⣿'
    if y < 50:
      if h <= 25:
        return '⠒'
      if h <= 50:
        return '⠶' 
      return '⣶'
    if y < 75:
      if h <= 25:
        return '⠤'
      return '⣤'
    return '⣀'

  def render_text(self, double=False):
    collapse = {
      '⠉ ': '⠁',
      '⠒ ': '⠂',
      '⠤ ': '⠄',
      '⣀ ': '⡀',
      '⠛ ': '⠃',
      '⠶ ': '⠆',
      '⣤ ': '⡄',
      '⠿ ': '⠇',
      '⣶ ': '⡆',
      '⣿ ': '⡇',
      ' ⠉': '⠈',
      ' ⠒': '⠐',
      ' ⠤': '⠠',
      ' ⣀': '⢀',
      ' ⠛': '⠘',
      ' ⠶': '⠰',
      ' ⣤': '⢠',
      ' ⠿': '⠸',
      ' ⣶': '⢰',
      ' ⣿': '⢸',
    }
    columns = []
    N = 8
    x, y, w, h = map(float, [self.x, self.y, self.w, self.h])
    if self.grid_spec:
      tx, ty = parse_grid_spec(self.grid_spec)
      x, w = map(tx, (x, w))
      y, h = map(ty, (y, h))
    for i in range(N):
      left = 100 * i / N
      right = 100 * (i + 1) / N
      if right < x or left > x + w:
        columns.append('⠀')
        continue
      columns.append(self._box_art(y, h))
    if not double:
      shortened = []
      for i in range(0, len(columns), 2):
        pair = '{}{}'.format(columns[i], columns[i + 1]).replace('⠀', ' ')
        shortened.append(collapse.get(pair, columns[i]))
      columns = shortened
    return '┃{}┃ (move and resize)'.format(''.join(columns))

  def serialize(self):
    args = ['MoveAndResize', self.x, self.y, self.w, self.h]
    if self.grid_spec:
      args.append(self.grid_spec)
    return args


class LoadSnapshot(WindowAction):
  """Window action that restores a snapshot.

  Doesn't care what the active window is.
  """

  def __init__(self, name):
    self.name = name

  def execute(self, window):
    load_window_state([self.name], {})

  def render_text(self):
    return 'Load Snapshot "{}"'.format(self.name)

  def serialize(self):
    return ['LoadSnapshot', self.name]


class KeyChords(object):
  """Stores keyboard shortcuts in class variables."""

  # Defaults if ~/.cache/goom/settings/shortcuts.json does not exist.
  _BUILTIN = {
    (frozenset(['c']),): MoveAndResize(1, 0, 4, 1, '6x1'),
    (frozenset(['Left']),): MoveAndResize(0, 0, 50, 100),
    (frozenset(['Right']),): MoveAndResize(50, 0, 50, 100),
    (frozenset(['Up']),): MoveAndResize(0, 0, 100, 50),
    (frozenset(['Down']),): MoveAndResize(0, 50, 100, 50),
    (frozenset(['Left', 'Up']),): MoveAndResize(0, 0, 50, 50),
    (frozenset(['Left', 'Down']),): MoveAndResize(0, 50, 50, 50),
    (frozenset(['Right', 'Up']),): MoveAndResize(50, 0, 50, 50),
    (frozenset(['Right', 'Down']),): MoveAndResize(50, 50, 50, 50),
    (frozenset(['1']),): MoveAndResize(0, 0, 1, 3, '3x3'),
    (frozenset(['2']),): MoveAndResize(0, 0, 2, 3, '3x3'),
    (frozenset(['3']),): MoveAndResize(2, 0, 1, 3, '3x3'),
    (frozenset(['4']),): MoveAndResize(1, 0, 2, 3, '3x3'),
    (frozenset(['Up']), frozenset(['Up']),): MoveAndResize(0, 0, 100, 100),
    (frozenset(['space']),): MoveAndResize(0, 0, 100, 100),
    (frozenset(['t']),): LoadSnapshot('foobar'),
  }

  _SHORTCUTS = dict(_BUILTIN)

  @classmethod
  def load(cls):
    if not os.path.exists(get_cache_file_path('settings/shortcuts.json')):
      cls._SHORTCUTS = dict(cls._BUILTIN)
      return
    with open_cache_file('settings/shortcuts.json', 'r') as f:
      try:
        data = json.loads(f.read())
      except Exception as e:
        sys.stderr.write(str(e))
        sys.stderr.flush()
        return
    cls._SHORTCUTS = {}
    for shortcut in data.get('shortcuts', []):
      chords = tuple(frozenset(chord.split('+')) for chord in shortcut.get('chords', '').split(' '))
      command = WindowAction.load(shortcut.get('action'))
      cls._SHORTCUTS[chords] = command

  @classmethod
  def save(cls):
    result = {}
    result['shortcuts'] = []
    for sequence in cls.get_sequences():
      result['shortcuts'].append({
        'chords': ' '.join('+'.join(sorted(c)) for c in sequence),
        'action': cls.get_command(sequence).serialize()
      })
    with open_cache_file('settings/shortcuts.json', 'w') as f:
      f.write('{\n  "shortcuts": [')
      for i, shortcut in enumerate(result['shortcuts']):
        if i > 0:
          f.write(',')
        f.write('\n    ')
        f.write(json.dumps(shortcut, sort_keys=True))
      f.write('\n  ]\n}')

  @classmethod
  def get_sequences(cls):
    return sorted(cls._SHORTCUTS, key=lambda chord: (len(chord),) + tuple(map(len, chord)))

  @classmethod
  def get_command(cls, chords):
    key = tuple(map(frozenset, ((s.upper() for s in cs) for cs in chords)))
    # Find longest trailing match.
    for sequence in reversed(cls.get_sequences()):
      seq = tuple(map(frozenset, ((s.upper() for s in cs) for cs in sequence)))
      if len(key) >= len(seq) and tuple(key[-len(seq):]) == seq:
        return cls._SHORTCUTS[sequence]
    return cls._SHORTCUTS.get(key)


class CommandServer(BaseHTTPRequestHandler):
  """Spins up a REST server that listens for commands, and executes them.

  The benefit for running the command daemon in the background is that you
  can see logs for events triggered by keyboard shortcuts, rather than just
  commands executed directly on the terminal.
  """

  @classmethod
  def start_server(cls):
    old_pid = get_daemon_pid()
    if old_pid is not None:
      try:
        check_output(['kill', '-9', old_pid])
      except:
        pass # It probably wasn't actually running.
    with open_cache_file('daemon.pid', 'w') as f:
      f.write(str(os.getpid()))
    try:
      KeyChords.load()
      print('Starting server ...')
      server = HTTPServer(('localhost', DAEMON_PORT), cls)
      server.serve_forever()
    except KeyboardInterrupt:
      print('Keyboard interrupt, shutting down.')
    finally:
      os.remove(get_cache_file_path('daemon.pid'))

  def do_POST(self):
    self.do_GET()

  def do_GET(self):
    print('Received GET', self.path)
    commands = get_commands(for_server=True)
    command_name = self.path[1:].replace('/', ' ')
    command_args = []
    space = command_name.find(' ')
    if space >= 0:
      command_args = command_name[space + 1:].split(' ')
      command_name = command_name[:space]
    if command_name not in commands:
      self.send_response(400)
      self.send_header('content-type', 'text/plain')
      self.end_headers()
      self.wfile.write('No such command {}'.format(command_name).encode())
      return
    try:
      Screen.clear_cache()
      positional, flags = parse_args(command_args)
      output = commands[command_name](positional, flags)
    except Exception as e:
      output = str(e)

    self.send_response(200)
    self.send_header('content-type', 'text/plain')
    self.end_headers()
    output_width = 0 if output is None else max(len(line) for line in output.split('\n'))
    self.wfile.write('Executed: {}\n{}\n{}'.format(' '.join([command_name]+command_args), '=' * output_width, output or '').encode())


class Screen(object):
  """Interrogates properties about a display.

  This is a literal screen, as in a monitor.
  """
  _SIZES = {}

  @classmethod
  def clear_cache(cls):
    cls._SIZES = {}

  def __init__(self, id):
    """Takes in the numeric id of the screen (from xprops or xdotool)."""
    self.id = id

  @property
  def size(self):
    """Returns the (width,height) of the screen in pixels."""
    if self.id not in Screen._SIZES:
      Screen._SIZES[self.id] = get_screen_size(self.id)
    return Screen._SIZES[self.id]

  def percent_to_pixel(self, percent_x, percent_y):
    """Converts coordinates given in percentages to pixel coordinates on this screen."""
    w, h = self.size
    return int(w * float(percent_x) / 100), int(h * float(percent_y) / 100)

  def pixel_to_percent(self, pixel_x, pixel_y):
    """Converts coordinates given in pixel coordinates on this screen to percentages."""
    w, h = self.size
    return 100 * float(pixel_x) / w, 100 * float(pixel_y) / h


class Window(object):
  """Interrogates and controls an X window.

  Shells out to xprops and xdotool to determine window properties, and xdotool to
  move and resize the window.
  """
  def __init__(self, id):
    self.id = id
    self._geometry = None
    self._props = None

  def clear_cache(self):
    """Window properties are cached to avoid shelling out to xprops/xdotool more than necessary.

    This method clears that cache, so you can read the updated properties in the event that
    the window is changed.
    """
    self._geometry = None
    self._props = None

  @property
  def geometry(self):
    """Geometry data, including the id of the screen this window is on, from xdotool."""
    if self._geometry is None:
      self._geometry = get_geometry(self.id)
    return self._geometry

  @property
  def props(self):
    """Dictionary of properties parsed from xprops output."""
    if self._props is None:
      self._props = get_window_props(self.id)
    return self._props

  @property
  def desktop(self):
    """The id of the desktop this window is on."""
    return self.props.get('_NET_WM_DESKTOP')

  @property
  def allowed_actions(self):
    """The allowed actions that can be performed on this window, acchording to xprops."""
    return self.props.get('_NET_WM_ALLOWED_ACTIONS', '').split(', ')

  @property
  def role(self):
    """The 'role' of this window, acchording to xprops.

    E.g., this might be ['browser'].
    """
    roles = self.props.get('WM_WINDOW_ROLE', [])
    return roles[0] if roles else ''

  @property
  def classes(self):
    """The 'classes' of this window, acchording to xpros.

    E.g., this might be ['Mozilla', 'Firefox']
    """
    return self.props.get('WM_CLASS', [])

  @property
  def name(self):
    """This is what appears in the title bar of the window."""
    for name in self.props.get('_NET_WM_NAME', []):
      return name
    for name in self.props.get('WM_NAME', []):
      return name
    return ''

  @property
  def pid(self):
    return self.props.get('_NET_WM_PID')

  @property
  def state(self):
    return self.props.get('_NET_WM_STATE') or self.props.get('WM_STATE')

  @property
  def screen(self):
    """The Screen object for the screen this window is currently displayed on."""
    return Screen(self.geometry.screen)

  def move(self, percent_x, percent_y):
    screen = self.screen
    x, y = screen.percent_to_pixel(percent_x, percent_y)
    xdotool('windowmove', self.id, x, y)

  def resize(self, percent_w, percent_h):
    screen = self.screen
    w, h = screen.percent_to_pixel(percent_w, percent_h)
    xdotool('windowsize', self.id, w, h)

  def move_and_resize(self, percent_x, percent_y, percent_w, percent_h, grid_spec=None):
    if grid_spec:
      tx, ty = parse_grid_spec(grid_spec)
      percent_x, percent_w = map(tx, (percent_x, percent_w))
      percent_y, percent_h = map(ty, (percent_y, percent_h))

    screen = self.screen
    x, y = screen.percent_to_pixel(percent_x, percent_y)
    w, h = screen.percent_to_pixel(percent_w, percent_h)

    inset_x, inset_y = INSET
    x += inset_x
    y += inset_y
    w -= inset_x * 2
    h -= inset_y * 2

    if float(percent_x) < 0:
      x = int(self.geometry.x)
    if float(percent_y) < 0:
      y = int(self.geometry.y)
    if float(percent_w) < 0:
      w = int(self.geometry.width)
    if float(percent_h) < 0:
      h = int(self.geometry.height)

    xdotool('windowsize', self.id, w, h)
    xdotool('windowmove', self.id, x, y)
    # Sometimes we don't end up quite where we wanted, because
    # we hit the edge of the screen. Correct the x,y position here:
    self.clear_cache()
    #print('0 Delta x/y', int(self.geometry.x) - x, int(self.geometry.y) - y)
    #print('0 Delta w/h', int(self.geometry.width) - w, int(self.geometry.height) - h)
    new_x, new_y = map(int, [self.geometry.x, self.geometry.y])
    delta_x, delta_y = new_x - x, new_y - y
    if delta_x == 0 and delta_y == 0:
      return

    target_x, target_y = x, y
    target_w, target_h = w, h

    if delta_x < 0:
      # We were too wide, and got shunted left.
      target_x += abs(delta_x)
      target_w -= abs(delta_x)
    elif delta_x > 0:
      # We went farther left than the desktop supports.
      target_w -= abs(delta_x)

    if delta_y < 0:
      # We tried to go too far down, and got shunted up.
      target_y += abs(delta_y)
      target_h -= abs(delta_y)
    elif delta_y > 0:
      # We went farther up than the desktop supports.
      target_h -= abs(delta_y)

    xdotool('windowsize', self.id, target_w, target_h)
    xdotool('windowmove', self.id, target_x, target_y)

    # Below just for debugging.
    #self.clear_cache()
    #new_w, new_h = map(int, [self.geometry.width, self.geometry.height])
    #delta_w, delta_h = new_w - w, new_h - h
    #print('1 Delta x/y', int(self.geometry.x) - x, int(self.geometry.y) - y)
    #print('1 Delta w/h', int(self.geometry.width) - w, int(self.geometry.height) - h)
    #print(self.geometry.x, self.geometry.y, self.geometry.width, self.geometry.height)
    #print()


class Geometry(object):
  """Stores geometry data about a window, parsed from xprops."""

  def __init__(self, id, x=None, y=None, width=None, height=None, screen=None):
    self.id = id
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.screen = screen

  def __repr__(self):
    return dedent('''
      Geom(
        id = {id}
        screen = {screen}
        x = {x}
        y = {y}
        width = {width}
        height = {height}
      )
    ''').strip().format(**self.as_dict())

  def as_dict(self):
    screen = Screen(self.screen)
    x, y = screen.pixel_to_percent(self.x, self.y)
    w, h = screen.pixel_to_percent(self.width, self.height)
    return {
      'id': self.id,
      'x': x,
      'y': y,
      'width': w,
      'height': h,
      'screen': self.screen,
    }


class KeyChordApp(tkinter.Frame):
  """Responsible for rendering the window that captures key events for chorded hotkeys."""

  def __init__(self, master=None):
    super().__init__(master)
    self.master = master
    self.active_window = xdotool('getactivewindow')
    self.pack(fill=tkinter.X, padx=10, pady=10)
    self.create_widgets()
    screen_width = master.winfo_screenwidth()
    screen_height = master.winfo_screenheight()
    w, h = master.winfo_reqwidth(), master.winfo_reqheight()
    master.geometry('+{}+{}'.format(
      int(screen_width/2 - w/2), int(screen_height/2 - h)
    ))
    self.bind('<KeyPress>', self.handle_keypress)
    self.bind('<KeyRelease>', self.handle_keyrelease)
    self.bind('<FocusOut>', lambda _: self.master.destroy())
    self.focus_set()
    self.chords = []
    self.current_chord = set()
    self.current_pressed = set()
    self.done = False

  def handle_keypress(self, event):
    key = KEY_NORMALIZE.get(event.keysym, event.keysym)
    if self.done:
      return
    if key == 'Escape':
      self.done = True
      self.master.destroy()
      return
    if key == 'Enter' or key == 'Return':
      self.chords.append(frozenset(self.current_chord))
      self.current_chord = set()
      self.done = True
      self.process_chords()
      self.master.destroy()
      return
    self.current_pressed.add(key)
    self.current_chord.add(key)

  def handle_keyrelease(self, event):
    key = KEY_NORMALIZE.get(event.keysym, event.keysym)
    if self.done or key == 'Escape':
      return
    if key in self.current_pressed:
      self.current_pressed.remove(key)
    if not self.current_pressed:
      # It would appear that this is the end
      # of a chord.
      self.chords.append(set(self.current_chord))
      if len(self.chords) > MAX_CORD_SEQUENCE:
        self.chords = self.chords[1:]
      self.current_chord = set()
      self.process_chords()

  def process_chords(self):
    chords = tuple(frozenset(c) for c in self.chords if len(c) > 0)
    command = KeyChords.get_command(chords)
    if command is not None:
      print('Execute', command.render_text())
      command.execute(Window(self.active_window))
    else:
      print('No commands for chord:',
        ' '.join('+'.join(c) for c in self.chords))

  def create_widgets(self):
    self.winfo_toplevel().title('goom - totally not moom')
    labels = []
    for sequence in KeyChords.get_sequences():
      command = KeyChords.get_command(sequence)
      key_text = ' '.join('+'.join(sorted(chord)) for chord in sequence)
      cmd_text = command.render_text()
      labels.append((key_text, cmd_text))
    longest_key_text = max(len(k) for k, c in labels)
    for key_text, cmd_text in labels:
      text = '{}: {}{}'.format(key_text, ' '*(longest_key_text - len(key_text)), cmd_text)
      w = tkinter.Label(self, text=text, anchor='w', font=('Noto Mono', 10))
      w.pack(side='top', fill=tkinter.X)
    self.quit = tkinter.Button(self,
      text='QUIT',
      command=self.master.destroy)
    self.quit.pack(side='bottom', padx=20, pady=20)


# === The below functions implement the CLI commands ===

def help():
  print(dedent('''
    Usage:
      goom <command> <args> <--flags>
  ''').strip())
  print()
  print('  Commands:')
  for command in get_commands().values():
    print('    {}'.format(command))


def save_window_state(positional, flags):
  """Saves a snapshot of the current desktop."""
  snapshot_name = positional[0] if positional else None
  if not snapshot_name:
    raise ValueError('Snapshot name is required.')
  hasher = sha1()
  hasher.update(snapshot_name.encode('utf8'))
  sid = hasher.hexdigest()
  windows = get_desktop_windows()
  with open_cache_file('snapshot/{}.json'.format(sid), 'w') as f:
    f.write(json.dumps({
      'name': snapshot_name,
      'windows': [{
        'geometry': w.geometry.as_dict(),
        'role': w.role,
        'name': w.name,
        'classes': w.classes,
        'state': w.state,
      } for w in windows],
    }, indent=2, sort_keys=True))


def load_window_state(positional, flags):
  """Load a snapshot into the current desktop."""
  snapshot_name = positional[0] if positional else None
  if not snapshot_name:
    raise ValueError('Snapshot name is required.')
  hasher = sha1()
  hasher.update(snapshot_name.encode('utf8'))
  sid = hasher.hexdigest()
  windows = get_desktop_windows()
  with open_cache_file('snapshot/{}.json'.format(sid), 'r') as f:
    snapshot = json.loads(f.read())
  pairs = []
  used = set()
  for snap_window in snapshot['windows']:
    for window in windows:
      if window.id in used:
        continue
      if tuple(snap_window['classes']) == tuple(window.classes):
        pairs.append((snap_window, window))
        used.add(window.id)
      break
  for snap_window, window in pairs:
    x_percent, y_percent = snap_window['geometry']['x'], snap_window['geometry']['y']
    w_percent, h_percent = snap_window['geometry']['width'], snap_window['geometry']['height']
    screen = Screen(window.geometry.screen)
    x, y = screen.percent_to_pixel(x_percent, y_percent)
    w, h = screen.percent_to_pixel(w_percent, h_percent)
    xdotool('windowmove', window.id, x, y, 'windowsize', window.id, w, h)


def print_window_props(positional, flags):
  results = []
  for id in positional:
    results.append(json.dumps(get_window_props(id), indent=2, sort_keys=True))
  return '\n'.join(results)


def process_key_chord(positional, flags):
  tk = tkinter.Tk()
  key_chord_app = KeyChordApp(master=tk)
  key_chord_app.mainloop()


def move_and_resize(positional, flags):
  tx = lambda x: x
  ty = lambda y: y

  if flags.get('grid') or flags.get('g'):
    tx, ty = parse_grid_spec(flags.get('grid') or flags.get('g'))

  active_window = Window(xdotool('getactivewindow'))
  x, y, w, h = (-1,) * 4

  if len(positional) == 4 and all(map(INT_PATTERN.match, positional)):
    x, y, w, h = positional
    x, w = map(tx, (x, w))
    y, h = map(ty, (y, h))
  elif len(positional) == 2 and all(map(INT_PATTERN.match, positional)):
    x, y = positional
    x = tx(x) ; y = ty(y)
  elif len(positional) == 2 and POS_PATTERN.match(positional[0]) and DIM_PATTERN.match(positional[1]):
    pos = POS_PATTERN.match(positional[0])
    dim = DIM_PATTERN.match(positional[1])
    x, y = pos.group('x'), pos.group('y')
    w, h = dim.group('w'), dim.group('h')
    x, w = map(tx, (x, w))
    y, h = map(ty, (y, h))
  elif len(positional) == 1 and ALL_PATTERN.match(positional[0]):
    match = ALL_PATTERN.match(positional[0])
    x, y = match.group('x'), match.group('y')
    w, h = match.group('w'), match.group('h')
    x, w = map(tx, (x, w))
    y, h = map(ty, (y, h))
  elif len(positional) == 1 and POS_PATTERN.match(positional[0]):
    pos = POS_PATTERN.match(positional[0])
    x, y = pos.group('x'), pos.group('y')
    x = tx(x) ; y = ty(y)
  elif len(positional) == 1 and DIM_PATTERN.match(positional[0]):
    dim = DIM_PATTERN.match(positional[0])
    w, h = dim.group('w'), dim.group('h')
    w = tx(w) ; h = ty(h)
  else:
    return dedent('''
      Invalid positional arguments. Usage:

        Move a window to x=10%, y=30%:
          move-and-resize 10 30
          move-and-resize 10,30

        Resize a window to w=50%, h=100%
          move-and-resize 50x100

        Move and resize a window to x=10%, y=30%, w=50%, h=20%
          move-and-resize 10 30 50 20
          move-and-resize 10,30 50x20
          move-and-resize '10,30 50x20'
    ''').strip()
  if float(w) < 0 and float(h) < 0:
    active_window.move(x, y)
    return
  active_window.move_and_resize(x, y, w, h)


def backup_shortcuts(positional, flags):
  path = get_cache_file_path('settings/shortcuts.json')
  if os.path.exists(path):
    shutil.copyfile(path, get_cache_file_path('settings/shortcuts.json.bak'))


def restore_shortcuts(positional, flags):
  path = get_cache_file_path('settings/shortcuts.json.bak')
  if os.path.exists(path):
    os.rename(path, get_cache_file_path('settings/shortcuts.json'))
  KeyChords.load()


def reset_shortcuts(positional, flags):
  path = get_cache_file_path('settings/shortcuts.json')
  if os.path.exists(path):
    os.remove(path)
  KeyChords.load()


def print_shortcuts(positional, flags):
  KeyChords.save()
  with open_cache_file('settings/shortcuts.json', 'r') as f:
    return f.read()
 
# ==== End CLI command functions ====


def parse_grid_spec(grid_spec=None):
  tx = lambda x: x
  ty = lambda y: y
  if grid_spec is None:
    return tx, ty
  # We interpret "0,0" as "rows,cols", and "0x0" as "width x height"
  m = POS_PATTERN.match(grid_spec)
  rows, cols = None, None
  if m:
    rows, cols = map(int, (m.group('x'), m.group('y')))
  m = DIM_PATTERN.match(grid_spec)
  if m:
    cols, rows = map(int, (m.group('w'), m.group('h')))
  if rows is None or cols is None:
    return dedent('''
      Expected --grid (-g) to be in one of the formats, but was {}:
        rows , cols
        width x height
    ''').format(grid_spec)
  tx = lambda x: 100 * float(x) / int(cols)
  ty = lambda y: 100 * float(y) / int(rows)
  return tx, ty
 

@contextmanager
def open_cache_file(name, mode):
  path = get_cache_file_path(name)
  if not os.path.exists(os.path.dirname(path)):
    os.makedirs(os.path.dirname(path))
  with open(path, mode) as f:
    yield f


def get_cache_file_path(name):
  return os.path.expanduser(os.path.join('~/.cache/goom', name))


def get_screen_size(id):
  output = check_output(['xrandr', '--screen', str(id)]).decode('utf-8')
  match = re.compile(r'\s+current\s+(?P<width>\d+)\s*x\s*(?P<height>\d+)\s*,').search(output)
  if not match:
    raise ValueError('Could not determine screen size from xrandr.')
  return int(match.group('width')), int(match.group('height'))


def get_geometry(wid):
  geom = Geometry(wid)
  for line in xdotool('getwindowgeometry', wid).split('\n'):
    wpm = WINDOW_PATTERN.search(line)
    if wpm is not None:
      geom.id = wpm.group('id')
      continue
    ppm = POSITION_PATTERN.search(line)
    if ppm is not None:
      geom.x = ppm.group('x')
      geom.y = ppm.group('y')
      geom.screen = ppm.group('screen')
      continue
    gpm = GEOMETRY_PATTERN.search(line)
    if gpm is not None:
      geom.width = gpm.group('width')
      geom.height = gpm.group('height')
  return geom


def get_desktop_windows():
  """Get windows for the active desktop."""
  desktop = xdotool('get_desktop').strip()
  results = []
  for id in get_all_window_ids():
    window = Window(id)
    if window.desktop != desktop:
      continue
    if '_NET_WM_ACTION_MOVE' not in window.allowed_actions:
      continue
    results.append(window)
  return results


def get_desktop_for_window(id):
  desktop = get_window_props(id).get('_NET_WM_DESKTOP')
  if desktop is None:
    raise ValueError('Could not identify desktop for {}'.format(id))
  return desktop


def get_window_props(id):
  current_prop_name = None
  current_prop_lines = None
  props = {}
  for line in xprop('-id', id).split('\n'):
    match_oneline = PROP_ONELINE.match(line)
    match_multiline = PROP_MULTILINE.match(line)
    if match_oneline or match_multiline:
      if current_prop_lines is not None:
        props[current_prop_name] = '\n'.join(current_prop_lines)
        current_prop_names, current_prop_lines = None, None
    else:
      if current_prop_lines is not None:
        current_prop_lines.append(line)
      continue
    match = match_oneline if match_oneline else match_multiline
    if match_oneline:
      raw_value = match.group('value')
      value = raw_value
      if match.group('type') == 'STRING' or match.group('type') == 'UTF8_STRING':
        value = json.loads('[{}]'.format(raw_value))
      props[match.group('name')] = value
    else:
      current_prop_name = match.group('name')
      current_prop_lines = [match.group('value')]
  if current_prop_lines is not None:
    props[current_prop_name] = '\n'.join(current_prop_lines)
  return { p: (dedent(value).strip() if isinstance(value, str) else value) for p, value in props.items() }


def get_all_window_ids():
  for line in xprop('-root').split('\n'):
    if line.startswith('_NET_CLIENT_LIST(WINDOW):'):
      return [int(s, 0) for s in line[line.find('#') + 1:].strip().split(', ')]
  raise ValueError('Failed to find window ids.') 


def get_daemon_pid():
  path = get_cache_file_path('daemon.pid')
  if not os.path.exists(path):
    return None
  with open(path, 'r') as f:
    return f.read().strip()


def xprop(*cmd):
  command = ['xprop']
  command.extend(map(str, cmd))
  return check_output(command).decode('utf-8').strip()


def xdotool(*cmd):
  command = ['xdotool']
  command.extend(map(str, cmd))
  return check_output(command).decode('utf-8').strip()


def get_commands(for_server=False):
  commands = [
    CliCommand('save-snapshot', 'Saves the state of windows on the active desktop.',
      save_window_state),
    CliCommand('load-snapshot', 'Loads the state of windows on the active desktop.',
      load_window_state),
    CliCommand('print-window-props', 'Dumps parsed information from xprop', print_window_props),
    CliCommand('key-chord', 'Opens the window allowing chorded keyboard shortcuts.', process_key_chord),
    CliCommand('move-and-resize', 'Move and resize a window.', move_and_resize),
    CliCommand('mar', 'Alias for move-and-resize.', move_and_resize),
    CliCommand('save-shortcuts', 'Save shortcuts to disk.', lambda _,__: KeyChords.save()),
    CliCommand('load-shortcuts', 'Load shortcuts from disk.', lambda _,__: KeyChords.load()),
    CliCommand('backup-shortcuts','Make a backup of the shortcuts file.', backup_shortcuts),
    CliCommand('restore-shortcuts', 'Restore the shortcuts file from backup.', restore_shortcuts),
    CliCommand('reset-shortcuts', 'Reset shortcuts to default.', reset_shortcuts),
    CliCommand('print-shortcuts', 'Print contents of current shortcuts.', print_shortcuts),
  ]
  if not for_server:
    commands.extend([
      CliCommand('daemon', 'Starts the command server daemon.',
        lambda pos, flags: CommandServer.start_server()),
    ])
  return { c.name: c for c in commands }


def main(positional, flags):
  commands = get_commands()
  if not positional:
    help()
    return
  command_name = positional[0]
  if command_name not in commands:
    help()
    return
  if command_name != 'daemon' and get_daemon_pid() is not None:
    # Prefer issue a GET request to the server.
    command_tokens = positional + ['--{}={}'.format(k, v) for k, v in flags.items()]
    try:
      with urllib.request.urlopen('http://localhost:{port}/{command_string}'.format(
        port=DAEMON_PORT,
        command_string='/'.join(command_tokens))) as f:
        print (f.read().decode('utf-8'))
        return
    except Exception as e:
      # This can happen if the daemon was killed too fast to clean up its own PID file,
      # e.g. if the computer is shutdown or the user is logged-out without cleanly
      # killing the process.
      sys.stderr.write('Daemon is not running, falling back on direct execution.\n')
      sys.stderr.flush()
  KeyChords.load()
  output = commands[command_name](positional[1:], flags)
  if output is not None:
    print(output)


def parse_args(sargs):
  """Yeh, I know, I'm not using argparse. I don't like its argument syntax.

  This very simple parser treats any token which does not start with a '-' as
  a positional argument, and any token which does start with a '-' as a flag.

  Flags have their leading '-' characters stripped, and are stuck in a map. If
  the flag contains an '=', the string before the equal sign is taken as the
  key, and the characters after as the value. Otherwise, the whole flag is used
  as the key, and the value is set to True.

  :returns: A tuple (positional, flags), where positional is a list and flags is
    a dict.
  """
  positional = []
  flags = {}
  for a in sargs:
    if a.startswith('-'):
      a = a.lstrip('-')
      eq = a.find('=')
      if eq > 0:
        flags[a[:eq]] = a[eq + 1:]
      else:
        flags[a] = True
    else:
      positional.append(a)
  return positional, flags


if __name__ == '__main__':
  main(*parse_args(sys.argv[1:]))
